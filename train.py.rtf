{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red113\green184\blue255;\red23\green23\blue23;\red202\green202\blue202;
\red89\green156\blue62;\red212\green212\blue212;\red194\green126\blue101;\red167\green197\blue152;}
{\*\expandedcolortbl;;\cssrgb\c50980\c77647\c100000;\cssrgb\c11765\c11765\c11765;\cssrgb\c83137\c83137\c83137;
\cssrgb\c41569\c66275\c30980;\cssrgb\c86275\c86275\c86275;\cssrgb\c80784\c56863\c47059;\cssrgb\c70980\c80784\c65882;}
\margl1440\margr1440\vieww28600\viewh15280\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 import\cf4 \strokec4  argparse\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  logging\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  math\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  os\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  random\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  time\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  warnings\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  copy \cf2 \strokec2 import\cf4 \strokec4  deepcopy\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  pathlib \cf2 \strokec2 import\cf4 \strokec4  Path\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  threading \cf2 \strokec2 import\cf4 \strokec4  Thread\cb1 \
\
\cf2 \cb3 \strokec2 import\cf4 \strokec4  numpy \cf2 \strokec2 as\cf4 \strokec4  np\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  torch.distributed \cf2 \strokec2 as\cf4 \strokec4  dist\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  torch.nn \cf2 \strokec2 as\cf4 \strokec4  nn\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  torch.nn.functional \cf2 \strokec2 as\cf4 \strokec4  F\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  torch.optim \cf2 \strokec2 as\cf4 \strokec4  optim\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  torch.optim.lr_scheduler \cf2 \strokec2 as\cf4 \strokec4  lr_scheduler\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  torch.utils.data\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  yaml\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  torch.cuda \cf2 \strokec2 import\cf4 \strokec4  amp\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  torch.nn.parallel \cf2 \strokec2 import\cf4 \strokec4  DistributedDataParallel \cf2 \strokec2 as\cf4 \strokec4  DDP\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  torch.utils.tensorboard \cf2 \strokec2 import\cf4 \strokec4  SummaryWriter\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  tqdm \cf2 \strokec2 import\cf4 \strokec4  tqdm\cb1 \
\
\cf2 \cb3 \strokec2 import\cf4 \strokec4  test  \cf5 \strokec5 # import test.py to get mAP after each epoch\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  models.experimental \cf2 \strokec2 import\cf4 \strokec4  attempt_load\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  models.yolo \cf2 \strokec2 import\cf4 \strokec4  Model\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.autoanchor \cf2 \strokec2 import\cf4 \strokec4  check_anchors\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.datasets \cf2 \strokec2 import\cf4 \strokec4  create_dataloader\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.general \cf2 \strokec2 import\cf4 \strokec4  labels_to_class_weights\cf6 \strokec6 ,\cf4 \strokec4  increment_path\cf6 \strokec6 ,\cf4 \strokec4  labels_to_image_weights\cf6 \strokec6 ,\cf4 \strokec4  init_seeds\cf6 \strokec6 ,\cf4 \strokec4  \\\cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     fitness\cf6 \strokec6 ,\cf4 \strokec4  strip_optimizer\cf6 \strokec6 ,\cf4 \strokec4  get_latest_run\cf6 \strokec6 ,\cf4 \strokec4  check_dataset\cf6 \strokec6 ,\cf4 \strokec4  check_file\cf6 \strokec6 ,\cf4 \strokec4  check_git_status\cf6 \strokec6 ,\cf4 \strokec4  check_img_size\cf6 \strokec6 ,\cf4 \strokec4  \\\cb1 \
\cb3     check_requirements\cf6 \strokec6 ,\cf4 \strokec4  print_mutation\cf6 \strokec6 ,\cf4 \strokec4  set_logging\cf6 \strokec6 ,\cf4 \strokec4  one_cycle\cf6 \strokec6 ,\cf4 \strokec4  colorstr\cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.google_utils \cf2 \strokec2 import\cf4 \strokec4  attempt_download\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.loss \cf2 \strokec2 import\cf4 \strokec4  ComputeLoss\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.plots \cf2 \strokec2 import\cf4 \strokec4  plot_images\cf6 \strokec6 ,\cf4 \strokec4  plot_labels\cf6 \strokec6 ,\cf4 \strokec4  plot_results\cf6 \strokec6 ,\cf4 \strokec4  plot_evolution\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.torch_utils \cf2 \strokec2 import\cf4 \strokec4  ModelEMA\cf6 \strokec6 ,\cf4 \strokec4  select_device\cf6 \strokec6 ,\cf4 \strokec4  intersect_dicts\cf6 \strokec6 ,\cf4 \strokec4  torch_distributed_zero_first\cf6 \strokec6 ,\cf4 \strokec4  de_parallel\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  utils.wandb_logging.wandb_utils \cf2 \strokec2 import\cf4 \strokec4  WandbLogger\cf6 \strokec6 ,\cf4 \strokec4  check_wandb_resume\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 logger = logging.getLogger\cf6 \strokec6 (\cf2 \strokec2 __name__\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 def\cf4 \strokec4  train\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 ,\cf4 \strokec4  opt\cf6 \strokec6 ,\cf4 \strokec4  device\cf6 \strokec6 ,\cf4 \strokec4  tb_writer=\cf2 \strokec2 None\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     logger.info\cf6 \strokec6 (\cf4 \strokec4 colorstr\cf6 \strokec6 (\cf7 \strokec7 'hyperparameters: '\cf6 \strokec6 )\cf4 \strokec4  + \cf7 \strokec7 ', '\cf4 \strokec4 .join\cf6 \strokec6 (\cf4 \strokec4 f\cf7 \strokec7 '\{k\}=\{v\}'\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  k\cf6 \strokec6 ,\cf4 \strokec4  v \cf2 \strokec2 in\cf4 \strokec4  hyp.items\cf6 \strokec6 ()))\cf4 \cb1 \strokec4 \
\cb3     save_dir\cf6 \strokec6 ,\cf4 \strokec4  epochs\cf6 \strokec6 ,\cf4 \strokec4  batch_size\cf6 \strokec6 ,\cf4 \strokec4  total_batch_size\cf6 \strokec6 ,\cf4 \strokec4  weights\cf6 \strokec6 ,\cf4 \strokec4  rank\cf6 \strokec6 ,\cf4 \strokec4  single_cls = \\\cb1 \
\cb3         Path\cf6 \strokec6 (\cf4 \strokec4 opt.save_dir\cf6 \strokec6 ),\cf4 \strokec4  opt.epochs\cf6 \strokec6 ,\cf4 \strokec4  opt.batch_size\cf6 \strokec6 ,\cf4 \strokec4  opt.total_batch_size\cf6 \strokec6 ,\cf4 \strokec4  opt.weights\cf6 \strokec6 ,\cf4 \strokec4  opt.global_rank\cf6 \strokec6 ,\cf4 \strokec4  \\\cb1 \
\cb3         opt.single_cls\cb1 \
\
\cb3     \cf5 \strokec5 # Directories\cf4 \cb1 \strokec4 \
\cb3     wdir = save_dir / \cf7 \strokec7 'weights'\cf4 \cb1 \strokec4 \
\cb3     wdir.mkdir\cf6 \strokec6 (\cf4 \strokec4 parents=\cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \strokec4  exist_ok=\cf2 \strokec2 True\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # make dir\cf4 \cb1 \strokec4 \
\cb3     last = wdir / \cf7 \strokec7 'last.pt'\cf4 \cb1 \strokec4 \
\cb3     best = wdir / \cf7 \strokec7 'best.pt'\cf4 \cb1 \strokec4 \
\cb3     results_file = save_dir / \cf7 \strokec7 'results.txt'\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Save run settings\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 with\cf4 \strokec4  \cf2 \strokec2 open\cf6 \strokec6 (\cf4 \strokec4 save_dir / \cf7 \strokec7 'hyp.yaml'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'w'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 as\cf4 \strokec4  f\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         yaml.safe_dump\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 ,\cf4 \strokec4  f\cf6 \strokec6 ,\cf4 \strokec4  sort_keys=\cf2 \strokec2 False\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 with\cf4 \strokec4  \cf2 \strokec2 open\cf6 \strokec6 (\cf4 \strokec4 save_dir / \cf7 \strokec7 'opt.yaml'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'w'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 as\cf4 \strokec4  f\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         yaml.safe_dump\cf6 \strokec6 (\cf2 \strokec2 vars\cf6 \strokec6 (\cf4 \strokec4 opt\cf6 \strokec6 ),\cf4 \strokec4  f\cf6 \strokec6 ,\cf4 \strokec4  sort_keys=\cf2 \strokec2 False\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Configure\cf4 \cb1 \strokec4 \
\cb3     plots = \cf2 \strokec2 not\cf4 \strokec4  opt.evolve  \cf5 \strokec5 # create plots\cf4 \cb1 \strokec4 \
\cb3     cuda = device.\cf2 \strokec2 type\cf4 \strokec4  != \cf7 \strokec7 'cpu'\cf4 \cb1 \strokec4 \
\cb3     init_seeds\cf6 \strokec6 (\cf8 \strokec8 2\cf4 \strokec4  + rank\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 with\cf4 \strokec4  \cf2 \strokec2 open\cf6 \strokec6 (\cf4 \strokec4 opt.data\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 as\cf4 \strokec4  f\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         data_dict = yaml.safe_load\cf6 \strokec6 (\cf4 \strokec4 f\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # data dict\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Logging- Doing this before checking the dataset. Might update data_dict\cf4 \cb1 \strokec4 \
\cb3     loggers = \cf6 \strokec6 \{\cf7 \strokec7 'wandb'\cf6 \strokec6 :\cf4 \strokec4  \cf2 \strokec2 None\cf6 \strokec6 \}\cf4 \strokec4   \cf5 \strokec5 # loggers dict\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3         opt.hyp = hyp  \cf5 \strokec5 # add hyperparameters\cf4 \cb1 \strokec4 \
\cb3         run_id = torch.load\cf6 \strokec6 (\cf4 \strokec4 weights\cf6 \strokec6 )\cf4 \strokec4 .get\cf6 \strokec6 (\cf7 \strokec7 'wandb_id'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  weights.endswith\cf6 \strokec6 (\cf7 \strokec7 '.pt'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  os.path.isfile\cf6 \strokec6 (\cf4 \strokec4 weights\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  \cf2 \strokec2 None\cf4 \cb1 \strokec4 \
\cb3         wandb_logger = WandbLogger\cf6 \strokec6 (\cf4 \strokec4 opt\cf6 \strokec6 ,\cf4 \strokec4  save_dir.stem\cf6 \strokec6 ,\cf4 \strokec4  run_id\cf6 \strokec6 ,\cf4 \strokec4  data_dict\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         loggers\cf6 \strokec6 [\cf7 \strokec7 'wandb'\cf6 \strokec6 ]\cf4 \strokec4  = wandb_logger.wandb\cb1 \
\cb3         data_dict = wandb_logger.data_dict\cb1 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  wandb_logger.wandb\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             weights\cf6 \strokec6 ,\cf4 \strokec4  epochs\cf6 \strokec6 ,\cf4 \strokec4  hyp = opt.weights\cf6 \strokec6 ,\cf4 \strokec4  opt.epochs\cf6 \strokec6 ,\cf4 \strokec4  opt.hyp  \cf5 \strokec5 # may update weights, epochs if resuming\cf4 \cb1 \strokec4 \
\
\cb3     nc = \cf8 \strokec8 1\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  single_cls \cf2 \strokec2 else\cf4 \strokec4  \cf2 \strokec2 int\cf6 \strokec6 (\cf4 \strokec4 data_dict\cf6 \strokec6 [\cf7 \strokec7 'nc'\cf6 \strokec6 ])\cf4 \strokec4   \cf5 \strokec5 # number of classes\cf4 \cb1 \strokec4 \
\cb3     names = \cf6 \strokec6 [\cf7 \strokec7 'item'\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  single_cls \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 data_dict\cf6 \strokec6 [\cf7 \strokec7 'names'\cf6 \strokec6 ])\cf4 \strokec4  != \cf8 \strokec8 1\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  data_dict\cf6 \strokec6 [\cf7 \strokec7 'names'\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # class names\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 assert\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 names\cf6 \strokec6 )\cf4 \strokec4  == nc\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 '%g names found for nc=%g dataset in %s'\cf4 \strokec4  % \cf6 \strokec6 (\cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 names\cf6 \strokec6 ),\cf4 \strokec4  nc\cf6 \strokec6 ,\cf4 \strokec4  opt.data\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # check\cf4 \cb1 \strokec4 \
\cb3     is_coco = opt.data.endswith\cf6 \strokec6 (\cf7 \strokec7 'coco.yaml'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  nc == \cf8 \strokec8 80\cf4 \strokec4   \cf5 \strokec5 # COCO dataset\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Model\cf4 \cb1 \strokec4 \
\cb3     pretrained = weights.endswith\cf6 \strokec6 (\cf7 \strokec7 '.pt'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  pretrained\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 with\cf4 \strokec4  torch_distributed_zero_first\cf6 \strokec6 (\cf4 \strokec4 rank\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3             weights = attempt_download\cf6 \strokec6 (\cf4 \strokec4 weights\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # download if not found locally\cf4 \cb1 \strokec4 \
\cb3         ckpt = torch.load\cf6 \strokec6 (\cf4 \strokec4 weights\cf6 \strokec6 ,\cf4 \strokec4  map_location=device\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # load checkpoint\cf4 \cb1 \strokec4 \
\cb3         model = Model\cf6 \strokec6 (\cf4 \strokec4 opt.cfg \cf2 \strokec2 or\cf4 \strokec4  ckpt\cf6 \strokec6 [\cf7 \strokec7 'model'\cf6 \strokec6 ]\cf4 \strokec4 .yaml\cf6 \strokec6 ,\cf4 \strokec4  ch=\cf8 \strokec8 3\cf6 \strokec6 ,\cf4 \strokec4  nc=nc\cf6 \strokec6 ,\cf4 \strokec4  anchors=hyp.get\cf6 \strokec6 (\cf7 \strokec7 'anchors'\cf6 \strokec6 ))\cf4 \strokec4 .to\cf6 \strokec6 (\cf4 \strokec4 device\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # create\cf4 \cb1 \strokec4 \
\cb3         exclude = \cf6 \strokec6 [\cf7 \strokec7 'anchor'\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 opt.cfg \cf2 \strokec2 or\cf4 \strokec4  hyp.get\cf6 \strokec6 (\cf7 \strokec7 'anchors'\cf6 \strokec6 ))\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.resume \cf2 \strokec2 else\cf4 \strokec4  \cf6 \strokec6 []\cf4 \strokec4   \cf5 \strokec5 # exclude keys\cf4 \cb1 \strokec4 \
\cb3         state_dict = ckpt\cf6 \strokec6 [\cf7 \strokec7 'model'\cf6 \strokec6 ]\cf4 \strokec4 .\cf2 \strokec2 float\cf6 \strokec6 ()\cf4 \strokec4 .state_dict\cf6 \strokec6 ()\cf4 \strokec4   \cf5 \strokec5 # to FP32\cf4 \cb1 \strokec4 \
\cb3         state_dict = intersect_dicts\cf6 \strokec6 (\cf4 \strokec4 state_dict\cf6 \strokec6 ,\cf4 \strokec4  model.state_dict\cf6 \strokec6 (),\cf4 \strokec4  exclude=exclude\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # intersect\cf4 \cb1 \strokec4 \
\cb3         model.load_state_dict\cf6 \strokec6 (\cf4 \strokec4 state_dict\cf6 \strokec6 ,\cf4 \strokec4  strict=\cf2 \strokec2 False\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # load\cf4 \cb1 \strokec4 \
\cb3         logger.info\cf6 \strokec6 (\cf7 \strokec7 'Transferred %g/%g items from %s'\cf4 \strokec4  % \cf6 \strokec6 (\cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 state_dict\cf6 \strokec6 ),\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 model.state_dict\cf6 \strokec6 ()),\cf4 \strokec4  weights\cf6 \strokec6 ))\cf4 \strokec4   \cf5 \strokec5 # report\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         model = Model\cf6 \strokec6 (\cf4 \strokec4 opt.cfg\cf6 \strokec6 ,\cf4 \strokec4  ch=\cf8 \strokec8 3\cf6 \strokec6 ,\cf4 \strokec4  nc=nc\cf6 \strokec6 ,\cf4 \strokec4  anchors=hyp.get\cf6 \strokec6 (\cf7 \strokec7 'anchors'\cf6 \strokec6 ))\cf4 \strokec4 .to\cf6 \strokec6 (\cf4 \strokec4 device\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # create\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 with\cf4 \strokec4  torch_distributed_zero_first\cf6 \strokec6 (\cf4 \strokec4 rank\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3         check_dataset\cf6 \strokec6 (\cf4 \strokec4 data_dict\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # check\cf4 \cb1 \strokec4 \
\cb3     train_path = data_dict\cf6 \strokec6 [\cf7 \strokec7 'train'\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3     test_path = data_dict\cf6 \strokec6 [\cf7 \strokec7 'val'\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Freeze\cf4 \cb1 \strokec4 \
\cb3     freeze = \cf6 \strokec6 []\cf4 \strokec4   \cf5 \strokec5 # parameter names to freeze (full or partial)\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 for\cf4 \strokec4  k\cf6 \strokec6 ,\cf4 \strokec4  v \cf2 \strokec2 in\cf4 \strokec4  model.named_parameters\cf6 \strokec6 ():\cf4 \cb1 \strokec4 \
\cb3         v.requires_grad = \cf2 \strokec2 True\cf4 \strokec4   \cf5 \strokec5 # train all layers\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 any\cf6 \strokec6 (\cf4 \strokec4 x \cf2 \strokec2 in\cf4 \strokec4  k \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  freeze\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 print\cf6 \strokec6 (\cf7 \strokec7 'freezing %s'\cf4 \strokec4  % k\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3             v.requires_grad = \cf2 \strokec2 False\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Optimizer\cf4 \cb1 \strokec4 \
\cb3     nbs = \cf8 \strokec8 64\cf4 \strokec4   \cf5 \strokec5 # nominal batch size\cf4 \cb1 \strokec4 \
\cb3     accumulate = \cf2 \strokec2 max\cf6 \strokec6 (\cf2 \strokec2 round\cf6 \strokec6 (\cf4 \strokec4 nbs / total_batch_size\cf6 \strokec6 ),\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # accumulate loss before optimizing\cf4 \cb1 \strokec4 \
\cb3     hyp\cf6 \strokec6 [\cf7 \strokec7 'weight_decay'\cf6 \strokec6 ]\cf4 \strokec4  *= total_batch_size * accumulate / nbs  \cf5 \strokec5 # scale weight_decay\cf4 \cb1 \strokec4 \
\cb3     logger.info\cf6 \strokec6 (\cf4 \strokec4 f\cf7 \strokec7 "Scaled weight_decay = \{hyp['weight_decay']\}"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     pg0\cf6 \strokec6 ,\cf4 \strokec4  pg1\cf6 \strokec6 ,\cf4 \strokec4  pg2 = \cf6 \strokec6 [],\cf4 \strokec4  \cf6 \strokec6 [],\cf4 \strokec4  \cf6 \strokec6 []\cf4 \strokec4   \cf5 \strokec5 # optimizer parameter groups\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 for\cf4 \strokec4  k\cf6 \strokec6 ,\cf4 \strokec4  v \cf2 \strokec2 in\cf4 \strokec4  model.named_modules\cf6 \strokec6 ():\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 hasattr\cf6 \strokec6 (\cf4 \strokec4 v\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'bias'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 isinstance\cf6 \strokec6 (\cf4 \strokec4 v.bias\cf6 \strokec6 ,\cf4 \strokec4  nn.Parameter\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3             pg2.append\cf6 \strokec6 (\cf4 \strokec4 v.bias\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # biases\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 isinstance\cf6 \strokec6 (\cf4 \strokec4 v\cf6 \strokec6 ,\cf4 \strokec4  nn.BatchNorm2d\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3             pg0.append\cf6 \strokec6 (\cf4 \strokec4 v.weight\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # no decay\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 elif\cf4 \strokec4  \cf2 \strokec2 hasattr\cf6 \strokec6 (\cf4 \strokec4 v\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'weight'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 isinstance\cf6 \strokec6 (\cf4 \strokec4 v.weight\cf6 \strokec6 ,\cf4 \strokec4  nn.Parameter\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3             pg1.append\cf6 \strokec6 (\cf4 \strokec4 v.weight\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # apply decay\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 if\cf4 \strokec4  opt.adam\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         optimizer = optim.Adam\cf6 \strokec6 (\cf4 \strokec4 pg0\cf6 \strokec6 ,\cf4 \strokec4  lr=hyp\cf6 \strokec6 [\cf7 \strokec7 'lr0'\cf6 \strokec6 ],\cf4 \strokec4  betas=\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 [\cf7 \strokec7 'momentum'\cf6 \strokec6 ],\cf4 \strokec4  \cf8 \strokec8 0.999\cf6 \strokec6 ))\cf4 \strokec4   \cf5 \strokec5 # adjust beta1 to momentum\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         optimizer = optim.SGD\cf6 \strokec6 (\cf4 \strokec4 pg0\cf6 \strokec6 ,\cf4 \strokec4  lr=hyp\cf6 \strokec6 [\cf7 \strokec7 'lr0'\cf6 \strokec6 ],\cf4 \strokec4  momentum=hyp\cf6 \strokec6 [\cf7 \strokec7 'momentum'\cf6 \strokec6 ],\cf4 \strokec4  nesterov=\cf2 \strokec2 True\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     optimizer.add_param_group\cf6 \strokec6 (\{\cf7 \strokec7 'params'\cf6 \strokec6 :\cf4 \strokec4  pg1\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'weight_decay'\cf6 \strokec6 :\cf4 \strokec4  hyp\cf6 \strokec6 [\cf7 \strokec7 'weight_decay'\cf6 \strokec6 ]\})\cf4 \strokec4   \cf5 \strokec5 # add pg1 with weight_decay\cf4 \cb1 \strokec4 \
\cb3     optimizer.add_param_group\cf6 \strokec6 (\{\cf7 \strokec7 'params'\cf6 \strokec6 :\cf4 \strokec4  pg2\cf6 \strokec6 \})\cf4 \strokec4   \cf5 \strokec5 # add pg2 (biases)\cf4 \cb1 \strokec4 \
\cb3     logger.info\cf6 \strokec6 (\cf7 \strokec7 'Optimizer groups: %g .bias, %g conv.weight, %g other'\cf4 \strokec4  % \cf6 \strokec6 (\cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 pg2\cf6 \strokec6 ),\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 pg1\cf6 \strokec6 ),\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 pg0\cf6 \strokec6 )))\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 del\cf4 \strokec4  pg0\cf6 \strokec6 ,\cf4 \strokec4  pg1\cf6 \strokec6 ,\cf4 \strokec4  pg2\cb1 \
\
\cb3     \cf5 \strokec5 # Scheduler https://arxiv.org/pdf/1812.01187.pdf\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 # https://pytorch.org/docs/stable/_modules/torch/optim/lr_scheduler.html#OneCycleLR\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  opt.linear_lr\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         lf = \cf2 \strokec2 lambda\cf4 \strokec4  x\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf4 \strokec4  - x / \cf6 \strokec6 (\cf4 \strokec4 epochs - \cf8 \strokec8 1\cf6 \strokec6 ))\cf4 \strokec4  * \cf6 \strokec6 (\cf8 \strokec8 1.0\cf4 \strokec4  - hyp\cf6 \strokec6 [\cf7 \strokec7 'lrf'\cf6 \strokec6 ])\cf4 \strokec4  + hyp\cf6 \strokec6 [\cf7 \strokec7 'lrf'\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # linear\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         lf = one_cycle\cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  hyp\cf6 \strokec6 [\cf7 \strokec7 'lrf'\cf6 \strokec6 ],\cf4 \strokec4  epochs\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # cosine 1->hyp['lrf']\cf4 \cb1 \strokec4 \
\cb3     scheduler = lr_scheduler.LambdaLR\cf6 \strokec6 (\cf4 \strokec4 optimizer\cf6 \strokec6 ,\cf4 \strokec4  lr_lambda=lf\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 # plot_lr_scheduler(optimizer, scheduler, epochs)\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # EMA\cf4 \cb1 \strokec4 \
\cb3     ema = ModelEMA\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  \cf2 \strokec2 None\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Resume\cf4 \cb1 \strokec4 \
\cb3     start_epoch\cf6 \strokec6 ,\cf4 \strokec4  best_fitness = \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  pretrained\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # Optimizer\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  ckpt\cf6 \strokec6 [\cf7 \strokec7 'optimizer'\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 is\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  \cf2 \strokec2 None\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             optimizer.load_state_dict\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 [\cf7 \strokec7 'optimizer'\cf6 \strokec6 ])\cf4 \cb1 \strokec4 \
\cb3             best_fitness = ckpt\cf6 \strokec6 [\cf7 \strokec7 'best_fitness'\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # EMA\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  ema \cf2 \strokec2 and\cf4 \strokec4  ckpt.get\cf6 \strokec6 (\cf7 \strokec7 'ema'\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3             ema.ema.load_state_dict\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 [\cf7 \strokec7 'ema'\cf6 \strokec6 ]\cf4 \strokec4 .\cf2 \strokec2 float\cf6 \strokec6 ()\cf4 \strokec4 .state_dict\cf6 \strokec6 ())\cf4 \cb1 \strokec4 \
\cb3             ema.updates = ckpt\cf6 \strokec6 [\cf7 \strokec7 'updates'\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # Results\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  ckpt.get\cf6 \strokec6 (\cf7 \strokec7 'training_results'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 is\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  \cf2 \strokec2 None\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             results_file.write_text\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 [\cf7 \strokec7 'training_results'\cf6 \strokec6 ])\cf4 \strokec4   \cf5 \strokec5 # write results.txt\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # Epochs\cf4 \cb1 \strokec4 \
\cb3         start_epoch = ckpt\cf6 \strokec6 [\cf7 \strokec7 'epoch'\cf6 \strokec6 ]\cf4 \strokec4  + \cf8 \strokec8 1\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  opt.resume\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 assert\cf4 \strokec4  start_epoch > \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 '%s training to %g epochs is finished, nothing to resume.'\cf4 \strokec4  % \cf6 \strokec6 (\cf4 \strokec4 weights\cf6 \strokec6 ,\cf4 \strokec4  epochs\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  epochs < start_epoch\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             logger.info\cf6 \strokec6 (\cf7 \strokec7 '%s has been trained for %g epochs. Fine-tuning for %g additional epochs.'\cf4 \strokec4  %\cb1 \
\cb3                         \cf6 \strokec6 (\cf4 \strokec4 weights\cf6 \strokec6 ,\cf4 \strokec4  ckpt\cf6 \strokec6 [\cf7 \strokec7 'epoch'\cf6 \strokec6 ],\cf4 \strokec4  epochs\cf6 \strokec6 ))\cf4 \cb1 \strokec4 \
\cb3             epochs += ckpt\cf6 \strokec6 [\cf7 \strokec7 'epoch'\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # finetune additional epochs\cf4 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 del\cf4 \strokec4  ckpt\cf6 \strokec6 ,\cf4 \strokec4  state_dict\cb1 \
\
\cb3     \cf5 \strokec5 # Image sizes\cf4 \cb1 \strokec4 \
\cb3     gs = \cf2 \strokec2 max\cf6 \strokec6 (\cf2 \strokec2 int\cf6 \strokec6 (\cf4 \strokec4 model.stride.\cf2 \strokec2 max\cf6 \strokec6 ()),\cf4 \strokec4  \cf8 \strokec8 32\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # grid size (max stride)\cf4 \cb1 \strokec4 \
\cb3     nl = model.model\cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ]\cf4 \strokec4 .nl  \cf5 \strokec5 # number of detection layers (used for scaling hyp['obj'])\cf4 \cb1 \strokec4 \
\cb3     imgsz\cf6 \strokec6 ,\cf4 \strokec4  imgsz_test = \cf6 \strokec6 [\cf4 \strokec4 check_img_size\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 ,\cf4 \strokec4  gs\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  opt.img_size\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # verify imgsz are gs-multiples\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # DP mode\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  cuda \cf2 \strokec2 and\cf4 \strokec4  rank == \cf8 \strokec8 -1\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  torch.cuda.device_count\cf6 \strokec6 ()\cf4 \strokec4  > \cf8 \strokec8 1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         model = torch.nn.DataParallel\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # SyncBatchNorm\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  opt.sync_bn \cf2 \strokec2 and\cf4 \strokec4  cuda \cf2 \strokec2 and\cf4 \strokec4  rank != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         model = torch.nn.SyncBatchNorm.convert_sync_batchnorm\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 )\cf4 \strokec4 .to\cf6 \strokec6 (\cf4 \strokec4 device\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         logger.info\cf6 \strokec6 (\cf7 \strokec7 'Using SyncBatchNorm()'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Trainloader\cf4 \cb1 \strokec4 \
\cb3     dataloader\cf6 \strokec6 ,\cf4 \strokec4  dataset = create_dataloader\cf6 \strokec6 (\cf4 \strokec4 train_path\cf6 \strokec6 ,\cf4 \strokec4  imgsz\cf6 \strokec6 ,\cf4 \strokec4  batch_size\cf6 \strokec6 ,\cf4 \strokec4  gs\cf6 \strokec6 ,\cf4 \strokec4  single_cls\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                             hyp=hyp\cf6 \strokec6 ,\cf4 \strokec4  augment=\cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \strokec4  cache=opt.cache_images\cf6 \strokec6 ,\cf4 \strokec4  rect=opt.rect\cf6 \strokec6 ,\cf4 \strokec4  rank=rank\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                             world_size=opt.world_size\cf6 \strokec6 ,\cf4 \strokec4  workers=opt.workers\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                             image_weights=opt.image_weights\cf6 \strokec6 ,\cf4 \strokec4  quad=opt.quad\cf6 \strokec6 ,\cf4 \strokec4  prefix=colorstr\cf6 \strokec6 (\cf7 \strokec7 'train: '\cf6 \strokec6 ))\cf4 \cb1 \strokec4 \
\cb3     mlc = np.concatenate\cf6 \strokec6 (\cf4 \strokec4 dataset.labels\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )[:,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \strokec4 .\cf2 \strokec2 max\cf6 \strokec6 ()\cf4 \strokec4   \cf5 \strokec5 # max label class\cf4 \cb1 \strokec4 \
\cb3     nb = \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 dataloader\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # number of batches\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 assert\cf4 \strokec4  mlc < nc\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'Label class %g exceeds nc=%g in %s. Possible class labels are 0-%g'\cf4 \strokec4  % \cf6 \strokec6 (\cf4 \strokec4 mlc\cf6 \strokec6 ,\cf4 \strokec4  nc\cf6 \strokec6 ,\cf4 \strokec4  opt.data\cf6 \strokec6 ,\cf4 \strokec4  nc - \cf8 \strokec8 1\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Process 0\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3         testloader = create_dataloader\cf6 \strokec6 (\cf4 \strokec4 test_path\cf6 \strokec6 ,\cf4 \strokec4  imgsz_test\cf6 \strokec6 ,\cf4 \strokec4  batch_size * \cf8 \strokec8 2\cf6 \strokec6 ,\cf4 \strokec4  gs\cf6 \strokec6 ,\cf4 \strokec4  single_cls\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                        hyp=hyp\cf6 \strokec6 ,\cf4 \strokec4  cache=opt.cache_images \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.notest\cf6 \strokec6 ,\cf4 \strokec4  rect=\cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \strokec4  rank=\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                        world_size=opt.world_size\cf6 \strokec6 ,\cf4 \strokec4  workers=opt.workers\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                        pad=\cf8 \strokec8 0.5\cf6 \strokec6 ,\cf4 \strokec4  prefix=colorstr\cf6 \strokec6 (\cf7 \strokec7 'val: '\cf6 \strokec6 ))[\cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.resume\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             labels = np.concatenate\cf6 \strokec6 (\cf4 \strokec4 dataset.labels\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3             c = torch.tensor\cf6 \strokec6 (\cf4 \strokec4 labels\cf6 \strokec6 [:,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ])\cf4 \strokec4   \cf5 \strokec5 # classes\cf4 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 # cf = torch.bincount(c.long(), minlength=nc) + 1.  # frequency\cf4 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 # model._initialize_biases(cf.to(device))\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  plots\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 plot_labels\cf6 \strokec6 (\cf4 \strokec4 labels\cf6 \strokec6 ,\cf4 \strokec4  names\cf6 \strokec6 ,\cf4 \strokec4  save_dir\cf6 \strokec6 ,\cf4 \strokec4  loggers\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  tb_writer\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     tb_writer.add_histogram\cf6 \strokec6 (\cf7 \strokec7 'classes'\cf6 \strokec6 ,\cf4 \strokec4  c\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Anchors\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.noautoanchor\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 check_anchors\cf6 \strokec6 (\cf4 \strokec4 dataset\cf6 \strokec6 ,\cf4 \strokec4  model=model\cf6 \strokec6 ,\cf4 \strokec4  thr=hyp\cf6 \strokec6 [\cf7 \strokec7 'anchor_t'\cf6 \strokec6 ],\cf4 \strokec4  imgsz=imgsz\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3             model.half\cf6 \strokec6 ()\cf4 \strokec4 .\cf2 \strokec2 float\cf6 \strokec6 ()\cf4 \strokec4   \cf5 \strokec5 # pre-reduce anchor precision\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # DDP mode\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  cuda \cf2 \strokec2 and\cf4 \strokec4  rank != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         model = DDP\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 ,\cf4 \strokec4  device_ids=\cf6 \strokec6 [\cf4 \strokec4 opt.local_rank\cf6 \strokec6 ],\cf4 \strokec4  output_device=opt.local_rank\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                     \cf5 \strokec5 # nn.MultiheadAttention incompatibility with DDP https://github.com/pytorch/pytorch/issues/26698\cf4 \cb1 \strokec4 \
\cb3                     find_unused_parameters=\cf2 \strokec2 any\cf6 \strokec6 (\cf2 \strokec2 isinstance\cf6 \strokec6 (\cf4 \strokec4 layer\cf6 \strokec6 ,\cf4 \strokec4  nn.MultiheadAttention\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  layer \cf2 \strokec2 in\cf4 \strokec4  model.modules\cf6 \strokec6 ()))\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Model parameters\cf4 \cb1 \strokec4 \
\cb3     hyp\cf6 \strokec6 [\cf7 \strokec7 'box'\cf6 \strokec6 ]\cf4 \strokec4  *= \cf8 \strokec8 3\cf4 \strokec4 . / nl  \cf5 \strokec5 # scale to layers\cf4 \cb1 \strokec4 \
\cb3     hyp\cf6 \strokec6 [\cf7 \strokec7 'cls'\cf6 \strokec6 ]\cf4 \strokec4  *= nc / \cf8 \strokec8 80\cf4 \strokec4 . * \cf8 \strokec8 3\cf4 \strokec4 . / nl  \cf5 \strokec5 # scale to classes and layers\cf4 \cb1 \strokec4 \
\cb3     hyp\cf6 \strokec6 [\cf7 \strokec7 'obj'\cf6 \strokec6 ]\cf4 \strokec4  *= \cf6 \strokec6 (\cf4 \strokec4 imgsz / \cf8 \strokec8 640\cf6 \strokec6 )\cf4 \strokec4  ** \cf8 \strokec8 2\cf4 \strokec4  * \cf8 \strokec8 3\cf4 \strokec4 . / nl  \cf5 \strokec5 # scale to image size and layers\cf4 \cb1 \strokec4 \
\cb3     hyp\cf6 \strokec6 [\cf7 \strokec7 'label_smoothing'\cf6 \strokec6 ]\cf4 \strokec4  = opt.label_smoothing\cb1 \
\cb3     model.nc = nc  \cf5 \strokec5 # attach number of classes to model\cf4 \cb1 \strokec4 \
\cb3     model.hyp = hyp  \cf5 \strokec5 # attach hyperparameters to model\cf4 \cb1 \strokec4 \
\cb3     model.gr = \cf8 \strokec8 1.0\cf4 \strokec4   \cf5 \strokec5 # iou loss ratio (obj_loss = 1.0 or iou)\cf4 \cb1 \strokec4 \
\cb3     model.class_weights = labels_to_class_weights\cf6 \strokec6 (\cf4 \strokec4 dataset.labels\cf6 \strokec6 ,\cf4 \strokec4  nc\cf6 \strokec6 )\cf4 \strokec4 .to\cf6 \strokec6 (\cf4 \strokec4 device\cf6 \strokec6 )\cf4 \strokec4  * nc  \cf5 \strokec5 # attach class weights\cf4 \cb1 \strokec4 \
\cb3     model.names = names\cb1 \
\
\cb3     \cf5 \strokec5 # Start training\cf4 \cb1 \strokec4 \
\cb3     t0 = time.time\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3     nw = \cf2 \strokec2 max\cf6 \strokec6 (\cf2 \strokec2 round\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 [\cf7 \strokec7 'warmup_epochs'\cf6 \strokec6 ]\cf4 \strokec4  * nb\cf6 \strokec6 ),\cf4 \strokec4  \cf8 \strokec8 1000\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # number of warmup iterations, max(3 epochs, 1k iterations)\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 # nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to < 1/2 of training\cf4 \cb1 \strokec4 \
\cb3     maps = np.zeros\cf6 \strokec6 (\cf4 \strokec4 nc\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # mAP per class\cf4 \cb1 \strokec4 \
\cb3     results = \cf6 \strokec6 (\cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)\cf4 \cb1 \strokec4 \
\cb3     scheduler.last_epoch = start_epoch - \cf8 \strokec8 1\cf4 \strokec4   \cf5 \strokec5 # do not move\cf4 \cb1 \strokec4 \
\cb3     scaler = amp.GradScaler\cf6 \strokec6 (\cf4 \strokec4 enabled=cuda\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     compute_loss = ComputeLoss\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # init loss class\cf4 \cb1 \strokec4 \
\cb3     logger.info\cf6 \strokec6 (\cf4 \strokec4 f\cf7 \strokec7 'Image sizes \{imgsz\} train, \{imgsz_test\} test\\n'\cf4 \cb1 \strokec4 \
\cb3                 f\cf7 \strokec7 'Using \{dataloader.num_workers\} dataloader workers\\n'\cf4 \cb1 \strokec4 \
\cb3                 f\cf7 \strokec7 'Logging results to \{save_dir\}\\n'\cf4 \cb1 \strokec4 \
\cb3                 f\cf7 \strokec7 'Starting training for \{epochs\} epochs...'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 for\cf4 \strokec4  epoch \cf2 \strokec2 in\cf4 \strokec4  \cf2 \strokec2 range\cf6 \strokec6 (\cf4 \strokec4 start_epoch\cf6 \strokec6 ,\cf4 \strokec4  epochs\cf6 \strokec6 ):\cf4 \strokec4   \cf5 \strokec5 # epoch ------------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cb3         model.train\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # Update image weights (optional)\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  opt.image_weights\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 # Generate indices\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3                 cw = model.class_weights.cpu\cf6 \strokec6 ()\cf4 \strokec4 .numpy\cf6 \strokec6 ()\cf4 \strokec4  * \cf6 \strokec6 (\cf8 \strokec8 1\cf4 \strokec4  - maps\cf6 \strokec6 )\cf4 \strokec4  ** \cf8 \strokec8 2\cf4 \strokec4  / nc  \cf5 \strokec5 # class weights\cf4 \cb1 \strokec4 \
\cb3                 iw = labels_to_image_weights\cf6 \strokec6 (\cf4 \strokec4 dataset.labels\cf6 \strokec6 ,\cf4 \strokec4  nc=nc\cf6 \strokec6 ,\cf4 \strokec4  class_weights=cw\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # image weights\cf4 \cb1 \strokec4 \
\cb3                 dataset.indices = random.choices\cf6 \strokec6 (\cf2 \strokec2 range\cf6 \strokec6 (\cf4 \strokec4 dataset.n\cf6 \strokec6 ),\cf4 \strokec4  weights=iw\cf6 \strokec6 ,\cf4 \strokec4  k=dataset.n\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # rand weighted idx\cf4 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 # Broadcast if DDP\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  rank != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 indices = \cf6 \strokec6 (\cf4 \strokec4 torch.tensor\cf6 \strokec6 (\cf4 \strokec4 dataset.indices\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  rank == \cf8 \strokec8 0\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  torch.zeros\cf6 \strokec6 (\cf4 \strokec4 dataset.n\cf6 \strokec6 ))\cf4 \strokec4 .\cf2 \strokec2 int\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3                 dist.broadcast\cf6 \strokec6 (\cf4 \strokec4 indices\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  rank != \cf8 \strokec8 0\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     dataset.indices = indices.cpu\cf6 \strokec6 ()\cf4 \strokec4 .numpy\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # Update mosaic border\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # dataset.mosaic_border = [b - imgsz, -b]  # height, width borders\cf4 \cb1 \strokec4 \
\
\cb3         mloss = torch.zeros\cf6 \strokec6 (\cf8 \strokec8 4\cf6 \strokec6 ,\cf4 \strokec4  device=device\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # mean losses\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  rank != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             dataloader.sampler.set_epoch\cf6 \strokec6 (\cf4 \strokec4 epoch\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         pbar = \cf2 \strokec2 enumerate\cf6 \strokec6 (\cf4 \strokec4 dataloader\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         logger.info\cf6 \strokec6 ((\cf7 \strokec7 '\\n'\cf4 \strokec4  + \cf7 \strokec7 '%10s'\cf4 \strokec4  * \cf8 \strokec8 8\cf6 \strokec6 )\cf4 \strokec4  % \cf6 \strokec6 (\cf7 \strokec7 'Epoch'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'gpu_mem'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'box'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'obj'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'cls'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'total'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'labels'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'img_size'\cf6 \strokec6 ))\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3             pbar = tqdm\cf6 \strokec6 (\cf4 \strokec4 pbar\cf6 \strokec6 ,\cf4 \strokec4  total=nb\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # progress bar\cf4 \cb1 \strokec4 \
\cb3         optimizer.zero_grad\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  i\cf6 \strokec6 ,\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 imgs\cf6 \strokec6 ,\cf4 \strokec4  targets\cf6 \strokec6 ,\cf4 \strokec4  paths\cf6 \strokec6 ,\cf4 \strokec4  _\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  pbar\cf6 \strokec6 :\cf4 \strokec4   \cf5 \strokec5 # batch -------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cb3             ni = i + nb * epoch  \cf5 \strokec5 # number integrated batches (since train start)\cf4 \cb1 \strokec4 \
\cb3             imgs = imgs.to\cf6 \strokec6 (\cf4 \strokec4 device\cf6 \strokec6 ,\cf4 \strokec4  non_blocking=\cf2 \strokec2 True\cf6 \strokec6 )\cf4 \strokec4 .\cf2 \strokec2 float\cf6 \strokec6 ()\cf4 \strokec4  / \cf8 \strokec8 255.0\cf4 \strokec4   \cf5 \strokec5 # uint8 to float32, 0-255 to 0.0-1.0\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Warmup\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  ni <= nw\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 xi = \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  nw\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # x interp\cf4 \cb1 \strokec4 \
\cb3                 \cf5 \strokec5 # model.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)\cf4 \cb1 \strokec4 \
\cb3                 accumulate = \cf2 \strokec2 max\cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  np.interp\cf6 \strokec6 (\cf4 \strokec4 ni\cf6 \strokec6 ,\cf4 \strokec4  xi\cf6 \strokec6 ,\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  nbs / total_batch_size\cf6 \strokec6 ])\cf4 \strokec4 .\cf2 \strokec2 round\cf6 \strokec6 ())\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 for\cf4 \strokec4  j\cf6 \strokec6 ,\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  \cf2 \strokec2 enumerate\cf6 \strokec6 (\cf4 \strokec4 optimizer.param_groups\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3                     \cf5 \strokec5 # bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\cf4 \cb1 \strokec4 \
\cb3                     x\cf6 \strokec6 [\cf7 \strokec7 'lr'\cf6 \strokec6 ]\cf4 \strokec4  = np.interp\cf6 \strokec6 (\cf4 \strokec4 ni\cf6 \strokec6 ,\cf4 \strokec4  xi\cf6 \strokec6 ,\cf4 \strokec4  \cf6 \strokec6 [\cf4 \strokec4 hyp\cf6 \strokec6 [\cf7 \strokec7 'warmup_bias_lr'\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  j == \cf8 \strokec8 2\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  x\cf6 \strokec6 [\cf7 \strokec7 'initial_lr'\cf6 \strokec6 ]\cf4 \strokec4  * lf\cf6 \strokec6 (\cf4 \strokec4 epoch\cf6 \strokec6 )])\cf4 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  \cf7 \strokec7 'momentum'\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  x\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                         x\cf6 \strokec6 [\cf7 \strokec7 'momentum'\cf6 \strokec6 ]\cf4 \strokec4  = np.interp\cf6 \strokec6 (\cf4 \strokec4 ni\cf6 \strokec6 ,\cf4 \strokec4  xi\cf6 \strokec6 ,\cf4 \strokec4  \cf6 \strokec6 [\cf4 \strokec4 hyp\cf6 \strokec6 [\cf7 \strokec7 'warmup_momentum'\cf6 \strokec6 ],\cf4 \strokec4  hyp\cf6 \strokec6 [\cf7 \strokec7 'momentum'\cf6 \strokec6 ]])\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Multi-scale\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  opt.multi_scale\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 sz = random.randrange\cf6 \strokec6 (\cf4 \strokec4 imgsz * \cf8 \strokec8 0.5\cf6 \strokec6 ,\cf4 \strokec4  imgsz * \cf8 \strokec8 1.5\cf4 \strokec4  + gs\cf6 \strokec6 )\cf4 \strokec4  // gs * gs  \cf5 \strokec5 # size\cf4 \cb1 \strokec4 \
\cb3                 sf = sz / \cf2 \strokec2 max\cf6 \strokec6 (\cf4 \strokec4 imgs.shape\cf6 \strokec6 [\cf8 \strokec8 2\cf6 \strokec6 :])\cf4 \strokec4   \cf5 \strokec5 # scale factor\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  sf != \cf8 \strokec8 1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     ns = \cf6 \strokec6 [\cf4 \strokec4 math.ceil\cf6 \strokec6 (\cf4 \strokec4 x * sf / gs\cf6 \strokec6 )\cf4 \strokec4  * gs \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  imgs.shape\cf6 \strokec6 [\cf8 \strokec8 2\cf6 \strokec6 :]]\cf4 \strokec4   \cf5 \strokec5 # new shape (stretched to gs-multiple)\cf4 \cb1 \strokec4 \
\cb3                     imgs = F.interpolate\cf6 \strokec6 (\cf4 \strokec4 imgs\cf6 \strokec6 ,\cf4 \strokec4  size=ns\cf6 \strokec6 ,\cf4 \strokec4  mode=\cf7 \strokec7 'bilinear'\cf6 \strokec6 ,\cf4 \strokec4  align_corners=\cf2 \strokec2 False\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Forward\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 with\cf4 \strokec4  amp.autocast\cf6 \strokec6 (\cf4 \strokec4 enabled=cuda\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3                 pred = model\cf6 \strokec6 (\cf4 \strokec4 imgs\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # forward\cf4 \cb1 \strokec4 \
\cb3                 loss\cf6 \strokec6 ,\cf4 \strokec4  loss_items = compute_loss\cf6 \strokec6 (\cf4 \strokec4 pred\cf6 \strokec6 ,\cf4 \strokec4  targets.to\cf6 \strokec6 (\cf4 \strokec4 device\cf6 \strokec6 ))\cf4 \strokec4   \cf5 \strokec5 # loss scaled by batch_size\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  rank != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     loss *= opt.world_size  \cf5 \strokec5 # gradient averaged between devices in DDP mode\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  opt.quad\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     loss *= \cf8 \strokec8 4\cf4 \strokec4 .\cb1 \
\
\cb3             \cf5 \strokec5 # Backward\cf4 \cb1 \strokec4 \
\cb3             scaler.scale\cf6 \strokec6 (\cf4 \strokec4 loss\cf6 \strokec6 )\cf4 \strokec4 .backward\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Optimize\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  ni % accumulate == \cf8 \strokec8 0\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 scaler.step\cf6 \strokec6 (\cf4 \strokec4 optimizer\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # optimizer.step\cf4 \cb1 \strokec4 \
\cb3                 scaler.update\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3                 optimizer.zero_grad\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  ema\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     ema.update\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Print\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3                 mloss = \cf6 \strokec6 (\cf4 \strokec4 mloss * i + loss_items\cf6 \strokec6 )\cf4 \strokec4  / \cf6 \strokec6 (\cf4 \strokec4 i + \cf8 \strokec8 1\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # update mean losses\cf4 \cb1 \strokec4 \
\cb3                 mem = \cf7 \strokec7 '%.3gG'\cf4 \strokec4  % \cf6 \strokec6 (\cf4 \strokec4 torch.cuda.memory_reserved\cf6 \strokec6 ()\cf4 \strokec4  / \cf8 \strokec8 1E9\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  torch.cuda.is_available\cf6 \strokec6 ()\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # (GB)\cf4 \cb1 \strokec4 \
\cb3                 s = \cf6 \strokec6 (\cf7 \strokec7 '%10s'\cf4 \strokec4  * \cf8 \strokec8 2\cf4 \strokec4  + \cf7 \strokec7 '%10.4g'\cf4 \strokec4  * \cf8 \strokec8 6\cf6 \strokec6 )\cf4 \strokec4  % \cf6 \strokec6 (\cf4 \cb1 \strokec4 \
\cb3                     f\cf7 \strokec7 '\{epoch\}/\{epochs - 1\}'\cf6 \strokec6 ,\cf4 \strokec4  mem\cf6 \strokec6 ,\cf4 \strokec4  *mloss\cf6 \strokec6 ,\cf4 \strokec4  targets.shape\cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ],\cf4 \strokec4  imgs.shape\cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ])\cf4 \cb1 \strokec4 \
\cb3                 pbar.set_description\cf6 \strokec6 (\cf4 \strokec4 s\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3                 \cf5 \strokec5 # Plot\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  plots \cf2 \strokec2 and\cf4 \strokec4  ni < \cf8 \strokec8 3\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     f = save_dir / f\cf7 \strokec7 'train_batch\{ni\}.jpg'\cf4 \strokec4   \cf5 \strokec5 # filename\cf4 \cb1 \strokec4 \
\cb3                     Thread\cf6 \strokec6 (\cf4 \strokec4 target=plot_images\cf6 \strokec6 ,\cf4 \strokec4  args=\cf6 \strokec6 (\cf4 \strokec4 imgs\cf6 \strokec6 ,\cf4 \strokec4  targets\cf6 \strokec6 ,\cf4 \strokec4  paths\cf6 \strokec6 ,\cf4 \strokec4  f\cf6 \strokec6 ),\cf4 \strokec4  daemon=\cf2 \strokec2 True\cf6 \strokec6 )\cf4 \strokec4 .start\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  tb_writer \cf2 \strokec2 and\cf4 \strokec4  ni == \cf8 \strokec8 0\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                         \cf2 \strokec2 with\cf4 \strokec4  warnings.catch_warnings\cf6 \strokec6 ():\cf4 \cb1 \strokec4 \
\cb3                             warnings.simplefilter\cf6 \strokec6 (\cf7 \strokec7 'ignore'\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # suppress jit trace warning\cf4 \cb1 \strokec4 \
\cb3                             tb_writer.add_graph\cf6 \strokec6 (\cf4 \strokec4 torch.jit.trace\cf6 \strokec6 (\cf4 \strokec4 de_parallel\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 ),\cf4 \strokec4  imgs\cf6 \strokec6 ,\cf4 \strokec4  strict=\cf2 \strokec2 False\cf6 \strokec6 ),\cf4 \strokec4  \cf6 \strokec6 [])\cf4 \strokec4   \cf5 \strokec5 # graph\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 elif\cf4 \strokec4  plots \cf2 \strokec2 and\cf4 \strokec4  ni == \cf8 \strokec8 10\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  wandb_logger.wandb\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     wandb_logger.log\cf6 \strokec6 (\{\cf7 \strokec7 'Mosaics'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 [\cf4 \strokec4 wandb_logger.wandb.Image\cf6 \strokec6 (\cf2 \strokec2 str\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 ),\cf4 \strokec4  caption=x.name\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \cb1 \strokec4 \
\cb3                                                   save_dir.glob\cf6 \strokec6 (\cf7 \strokec7 'train*.jpg'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  x.exists\cf6 \strokec6 ()]\})\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # end batch ------------------------------------------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # end epoch ----------------------------------------------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # Scheduler\cf4 \cb1 \strokec4 \
\cb3         lr = \cf6 \strokec6 [\cf4 \strokec4 x\cf6 \strokec6 [\cf7 \strokec7 'lr'\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  optimizer.param_groups\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # for tensorboard\cf4 \cb1 \strokec4 \
\cb3         scheduler.step\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # DDP process 0 or single-GPU\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 # mAP\cf4 \cb1 \strokec4 \
\cb3             ema.update_attr\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 ,\cf4 \strokec4  include=\cf6 \strokec6 [\cf7 \strokec7 'yaml'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'nc'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'hyp'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'gr'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'names'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'stride'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'class_weights'\cf6 \strokec6 ])\cf4 \cb1 \strokec4 \
\cb3             final_epoch = epoch + \cf8 \strokec8 1\cf4 \strokec4  == epochs\cb1 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.notest \cf2 \strokec2 or\cf4 \strokec4  final_epoch\cf6 \strokec6 :\cf4 \strokec4   \cf5 \strokec5 # Calculate mAP\cf4 \cb1 \strokec4 \
\cb3                 wandb_logger.current_epoch = epoch + \cf8 \strokec8 1\cf4 \cb1 \strokec4 \
\cb3                 results\cf6 \strokec6 ,\cf4 \strokec4  maps\cf6 \strokec6 ,\cf4 \strokec4  _ = test.test\cf6 \strokec6 (\cf4 \strokec4 data_dict\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              batch_size=batch_size * \cf8 \strokec8 2\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              imgsz=imgsz_test\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              model=ema.ema\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              single_cls=single_cls\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              dataloader=testloader\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              save_dir=save_dir\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              save_json=is_coco \cf2 \strokec2 and\cf4 \strokec4  final_epoch\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              verbose=nc < \cf8 \strokec8 50\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  final_epoch\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              plots=plots \cf2 \strokec2 and\cf4 \strokec4  final_epoch\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              wandb_logger=wandb_logger\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                              compute_loss=compute_loss\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Write\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 with\cf4 \strokec4  \cf2 \strokec2 open\cf6 \strokec6 (\cf4 \strokec4 results_file\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'a'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 as\cf4 \strokec4  f\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 f.write\cf6 \strokec6 (\cf4 \strokec4 s + \cf7 \strokec7 '%10.4g'\cf4 \strokec4  * \cf8 \strokec8 7\cf4 \strokec4  % results + \cf7 \strokec7 '\\n'\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # append metrics, val_loss\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Log\cf4 \cb1 \strokec4 \
\cb3             tags = \cf6 \strokec6 [\cf7 \strokec7 'train/box_loss'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'train/obj_loss'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'train/cls_loss'\cf6 \strokec6 ,\cf4 \strokec4   \cf5 \strokec5 # train loss\cf4 \cb1 \strokec4 \
\cb3                     \cf7 \strokec7 'metrics/precision'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'metrics/recall'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'metrics/mAP_0.5'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'metrics/mAP_0.5:0.95'\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                     \cf7 \strokec7 'val/box_loss'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'val/obj_loss'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'val/cls_loss'\cf6 \strokec6 ,\cf4 \strokec4   \cf5 \strokec5 # val loss\cf4 \cb1 \strokec4 \
\cb3                     \cf7 \strokec7 'x/lr0'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'x/lr1'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'x/lr2'\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # params\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  x\cf6 \strokec6 ,\cf4 \strokec4  tag \cf2 \strokec2 in\cf4 \strokec4  \cf2 \strokec2 zip\cf6 \strokec6 (\cf2 \strokec2 list\cf6 \strokec6 (\cf4 \strokec4 mloss\cf6 \strokec6 [:\cf8 \strokec8 -1\cf6 \strokec6 ])\cf4 \strokec4  + \cf2 \strokec2 list\cf6 \strokec6 (\cf4 \strokec4 results\cf6 \strokec6 )\cf4 \strokec4  + lr\cf6 \strokec6 ,\cf4 \strokec4  tags\cf6 \strokec6 ):\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  tb_writer\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     tb_writer.add_scalar\cf6 \strokec6 (\cf4 \strokec4 tag\cf6 \strokec6 ,\cf4 \strokec4  x\cf6 \strokec6 ,\cf4 \strokec4  epoch\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # tensorboard\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  wandb_logger.wandb\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     wandb_logger.log\cf6 \strokec6 (\{\cf4 \strokec4 tag\cf6 \strokec6 :\cf4 \strokec4  x\cf6 \strokec6 \})\cf4 \strokec4   \cf5 \strokec5 # W&B\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Update best mAP\cf4 \cb1 \strokec4 \
\cb3             fi = fitness\cf6 \strokec6 (\cf4 \strokec4 np.array\cf6 \strokec6 (\cf4 \strokec4 results\cf6 \strokec6 )\cf4 \strokec4 .reshape\cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 -1\cf6 \strokec6 ))\cf4 \strokec4   \cf5 \strokec5 # weighted combination of [P, R, mAP@.5, mAP@.5-.95]\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  fi > best_fitness\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 best_fitness = fi\cb1 \
\cb3             wandb_logger.end_epoch\cf6 \strokec6 (\cf4 \strokec4 best_result=best_fitness == fi\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Save model\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  \cf6 \strokec6 (\cf2 \strokec2 not\cf4 \strokec4  opt.nosave\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 or\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 final_epoch \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.evolve\cf6 \strokec6 ):\cf4 \strokec4   \cf5 \strokec5 # if save\cf4 \cb1 \strokec4 \
\cb3                 ckpt = \cf6 \strokec6 \{\cf7 \strokec7 'epoch'\cf6 \strokec6 :\cf4 \strokec4  epoch\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'best_fitness'\cf6 \strokec6 :\cf4 \strokec4  best_fitness\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'training_results'\cf6 \strokec6 :\cf4 \strokec4  results_file.read_text\cf6 \strokec6 (),\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'model'\cf6 \strokec6 :\cf4 \strokec4  deepcopy\cf6 \strokec6 (\cf4 \strokec4 de_parallel\cf6 \strokec6 (\cf4 \strokec4 model\cf6 \strokec6 ))\cf4 \strokec4 .half\cf6 \strokec6 (),\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'ema'\cf6 \strokec6 :\cf4 \strokec4  deepcopy\cf6 \strokec6 (\cf4 \strokec4 ema.ema\cf6 \strokec6 )\cf4 \strokec4 .half\cf6 \strokec6 (),\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'updates'\cf6 \strokec6 :\cf4 \strokec4  ema.updates\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'optimizer'\cf6 \strokec6 :\cf4 \strokec4  optimizer.state_dict\cf6 \strokec6 (),\cf4 \cb1 \strokec4 \
\cb3                         \cf7 \strokec7 'wandb_id'\cf6 \strokec6 :\cf4 \strokec4  wandb_logger.wandb_run.\cf2 \strokec2 id\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  wandb_logger.wandb \cf2 \strokec2 else\cf4 \strokec4  \cf2 \strokec2 None\cf6 \strokec6 \}\cf4 \cb1 \strokec4 \
\
\cb3                 \cf5 \strokec5 # Save last, best and delete\cf4 \cb1 \strokec4 \
\cb3                 torch.save\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 ,\cf4 \strokec4  last\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  best_fitness == fi\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     torch.save\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 ,\cf4 \strokec4  best\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  wandb_logger.wandb\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 if\cf4 \strokec4  \cf6 \strokec6 ((\cf4 \strokec4 epoch + \cf8 \strokec8 1\cf6 \strokec6 )\cf4 \strokec4  % opt.save_period == \cf8 \strokec8 0\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  final_epoch\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 and\cf4 \strokec4  opt.save_period != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                         wandb_logger.log_model\cf6 \strokec6 (\cf4 \cb1 \strokec4 \
\cb3                             last.parent\cf6 \strokec6 ,\cf4 \strokec4  opt\cf6 \strokec6 ,\cf4 \strokec4  epoch\cf6 \strokec6 ,\cf4 \strokec4  fi\cf6 \strokec6 ,\cf4 \strokec4  best_model=best_fitness == fi\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 del\cf4 \strokec4  ckpt\cb1 \
\
\cb3         \cf5 \strokec5 # end epoch ----------------------------------------------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 # end training\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3         logger.info\cf6 \strokec6 (\cf4 \strokec4 f\cf7 \strokec7 '\{epoch - start_epoch + 1\} epochs completed in \{(time.time() - t0) / 3600:.3f\} hours.\\n'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  plots\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             plot_results\cf6 \strokec6 (\cf4 \strokec4 save_dir=save_dir\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # save as results.png\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  wandb_logger.wandb\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 files = \cf6 \strokec6 [\cf7 \strokec7 'results.png'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'confusion_matrix.png'\cf6 \strokec6 ,\cf4 \strokec4  *\cf6 \strokec6 [\cf4 \strokec4 f\cf7 \strokec7 '\{x\}_curve.png'\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 'F1'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'PR'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'P'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'R'\cf6 \strokec6 )]]\cf4 \cb1 \strokec4 \
\cb3                 wandb_logger.log\cf6 \strokec6 (\{\cf7 \strokec7 "Results"\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 [\cf4 \strokec4 wandb_logger.wandb.Image\cf6 \strokec6 (\cf2 \strokec2 str\cf6 \strokec6 (\cf4 \strokec4 save_dir / f\cf6 \strokec6 ),\cf4 \strokec4  caption=f\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  f \cf2 \strokec2 in\cf4 \strokec4  files\cb1 \
\cb3                                               \cf2 \strokec2 if\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 save_dir / f\cf6 \strokec6 )\cf4 \strokec4 .exists\cf6 \strokec6 ()]\})\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.evolve\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  is_coco\cf6 \strokec6 :\cf4 \strokec4   \cf5 \strokec5 # COCO dataset\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 for\cf4 \strokec4  m \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf4 \strokec4 last\cf6 \strokec6 ,\cf4 \strokec4  best\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  best.exists\cf6 \strokec6 ()\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  \cf6 \strokec6 [\cf4 \strokec4 last\cf6 \strokec6 ]:\cf4 \strokec4   \cf5 \strokec5 # speed, mAP tests\cf4 \cb1 \strokec4 \
\cb3                     results\cf6 \strokec6 ,\cf4 \strokec4  _\cf6 \strokec6 ,\cf4 \strokec4  _ = test.test\cf6 \strokec6 (\cf4 \strokec4 opt.data\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               batch_size=batch_size * \cf8 \strokec8 2\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               imgsz=imgsz_test\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               conf_thres=\cf8 \strokec8 0.001\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               iou_thres=\cf8 \strokec8 0.7\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               model=attempt_load\cf6 \strokec6 (\cf4 \strokec4 m\cf6 \strokec6 ,\cf4 \strokec4  device\cf6 \strokec6 )\cf4 \strokec4 .half\cf6 \strokec6 (),\cf4 \cb1 \strokec4 \
\cb3                                               single_cls=single_cls\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               dataloader=testloader\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               save_dir=save_dir\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               save_json=\cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                               plots=\cf2 \strokec2 False\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Strip optimizers\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  f \cf2 \strokec2 in\cf4 \strokec4  last\cf6 \strokec6 ,\cf4 \strokec4  best\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  f.exists\cf6 \strokec6 ():\cf4 \cb1 \strokec4 \
\cb3                     strip_optimizer\cf6 \strokec6 (\cf4 \strokec4 f\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # strip optimizers\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  wandb_logger.wandb\cf6 \strokec6 :\cf4 \strokec4   \cf5 \strokec5 # Log the stripped model\cf4 \cb1 \strokec4 \
\cb3                 wandb_logger.wandb.log_artifact\cf6 \strokec6 (\cf2 \strokec2 str\cf6 \strokec6 (\cf4 \strokec4 best \cf2 \strokec2 if\cf4 \strokec4  best.exists\cf6 \strokec6 ()\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  last\cf6 \strokec6 ),\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf7 \strokec7 'model'\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                                 name=\cf7 \strokec7 'run_'\cf4 \strokec4  + wandb_logger.wandb_run.\cf2 \strokec2 id\cf4 \strokec4  + \cf7 \strokec7 '_model'\cf6 \strokec6 ,\cf4 \cb1 \strokec4 \
\cb3                                                 aliases=\cf6 \strokec6 [\cf7 \strokec7 'latest'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'best'\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'stripped'\cf6 \strokec6 ])\cf4 \cb1 \strokec4 \
\cb3         wandb_logger.finish_run\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         dist.destroy_process_group\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3     torch.cuda.empty_cache\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 return\cf4 \strokec4  results\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 __name__\cf4 \strokec4  == \cf7 \strokec7 '__main__'\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     parser = argparse.ArgumentParser\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--weights'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 str\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 'yolov5s.pt'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'initial weights path'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--cfg'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 str\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 'models/yolov5s.yaml'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'model.yaml path'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--data'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 str\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 'data/coco128.yaml'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'dataset.yaml path'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--hyp'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 str\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 'data/hyp.scratch.yaml'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'hyperparameters path'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--epochs'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 300\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--batch-size'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 16\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'total batch size for all GPUs'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--img-size'\cf6 \strokec6 ,\cf4 \strokec4  nargs=\cf7 \strokec7 '+'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf6 \strokec6 [\cf8 \strokec8 640\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 640\cf6 \strokec6 ],\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 '[train, test] image sizes'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--rect'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'rectangular training'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--resume'\cf6 \strokec6 ,\cf4 \strokec4  nargs=\cf7 \strokec7 '?'\cf6 \strokec6 ,\cf4 \strokec4  const=\cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \strokec4  default=\cf2 \strokec2 False\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'resume most recent training'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--nosave'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'only save final checkpoint'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--notest'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'only test final epoch'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--noautoanchor'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'disable autoanchor check'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--evolve'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'evolve hyperparameters'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--bucket'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 str\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 ''\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'gsutil bucket'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--cache-images'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'cache images for faster training'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--image-weights'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'use weighted image selection for training'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--device'\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 ''\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'cuda device, i.e. 0 or 0,1,2,3 or cpu'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--multi-scale'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'vary img-size +/- 50%%'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--single-cls'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'train multi-class data as single-class'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--adam'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'use torch.optim.Adam() optimizer'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--sync-bn'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'use SyncBatchNorm, only available in DDP mode'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--local_rank'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'DDP parameter, do not modify'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--workers'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 8\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'maximum number of dataloader workers'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--project'\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 'runs/train'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'save to project/name'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--entity'\cf6 \strokec6 ,\cf4 \strokec4  default=\cf2 \strokec2 None\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'W&B entity'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--name'\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 'exp'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'save to project/name'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--exist-ok'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'existing project/name ok, do not increment'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--quad'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'quad dataloader'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--linear-lr'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'linear LR'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--label-smoothing'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 float\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'Label smoothing epsilon'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--upload_dataset'\cf6 \strokec6 ,\cf4 \strokec4  action=\cf7 \strokec7 'store_true'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'Upload dataset as W&B artifact table'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--bbox_interval'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'Set bounding-box image logging interval for W&B'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--save_period'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 int\cf6 \strokec6 ,\cf4 \strokec4  default=\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'Log model after every "save_period" epoch'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     parser.add_argument\cf6 \strokec6 (\cf7 \strokec7 '--artifact_alias'\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 type\cf4 \strokec4 =\cf2 \strokec2 str\cf6 \strokec6 ,\cf4 \strokec4  default=\cf7 \strokec7 "latest"\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 help\cf4 \strokec4 =\cf7 \strokec7 'version of dataset artifact to be used'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     opt = parser.parse_args\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Set DDP variables\cf4 \cb1 \strokec4 \
\cb3     opt.world_size = \cf2 \strokec2 int\cf6 \strokec6 (\cf4 \strokec4 os.environ\cf6 \strokec6 [\cf7 \strokec7 'WORLD_SIZE'\cf6 \strokec6 ])\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  \cf7 \strokec7 'WORLD_SIZE'\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  os.environ \cf2 \strokec2 else\cf4 \strokec4  \cf8 \strokec8 1\cf4 \cb1 \strokec4 \
\cb3     opt.global_rank = \cf2 \strokec2 int\cf6 \strokec6 (\cf4 \strokec4 os.environ\cf6 \strokec6 [\cf7 \strokec7 'RANK'\cf6 \strokec6 ])\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  \cf7 \strokec7 'RANK'\cf4 \strokec4  \cf2 \strokec2 in\cf4 \strokec4  os.environ \cf2 \strokec2 else\cf4 \strokec4  \cf8 \strokec8 -1\cf4 \cb1 \strokec4 \
\cb3     set_logging\cf6 \strokec6 (\cf4 \strokec4 opt.global_rank\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  opt.global_rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # check_git_status()\cf4 \cb1 \strokec4 \
\cb3         check_requirements\cf6 \strokec6 (\cf4 \strokec4 exclude=\cf6 \strokec6 [\cf7 \strokec7 'thop'\cf6 \strokec6 ])\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Resume\cf4 \cb1 \strokec4 \
\cb3     wandb_run = check_wandb_resume\cf6 \strokec6 (\cf4 \strokec4 opt\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  opt.resume \cf2 \strokec2 and\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  wandb_run\cf6 \strokec6 :\cf4 \strokec4   \cf5 \strokec5 # resume an interrupted run\cf4 \cb1 \strokec4 \
\cb3         ckpt = opt.resume \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 isinstance\cf6 \strokec6 (\cf4 \strokec4 opt.resume\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 str\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 else\cf4 \strokec4  get_latest_run\cf6 \strokec6 ()\cf4 \strokec4   \cf5 \strokec5 # specified or most recent path\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 assert\cf4 \strokec4  os.path.isfile\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 ),\cf4 \strokec4  \cf7 \strokec7 'ERROR: --resume checkpoint does not exist'\cf4 \cb1 \strokec4 \
\cb3         apriori = opt.global_rank\cf6 \strokec6 ,\cf4 \strokec4  opt.local_rank\cb1 \
\cb3         \cf2 \strokec2 with\cf4 \strokec4  \cf2 \strokec2 open\cf6 \strokec6 (\cf4 \strokec4 Path\cf6 \strokec6 (\cf4 \strokec4 ckpt\cf6 \strokec6 )\cf4 \strokec4 .parent.parent / \cf7 \strokec7 'opt.yaml'\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 as\cf4 \strokec4  f\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             opt = argparse.Namespace\cf6 \strokec6 (\cf4 \strokec4 **yaml.safe_load\cf6 \strokec6 (\cf4 \strokec4 f\cf6 \strokec6 ))\cf4 \strokec4   \cf5 \strokec5 # replace\cf4 \cb1 \strokec4 \
\cb3         opt.cfg\cf6 \strokec6 ,\cf4 \strokec4  opt.weights\cf6 \strokec6 ,\cf4 \strokec4  opt.resume\cf6 \strokec6 ,\cf4 \strokec4  opt.batch_size\cf6 \strokec6 ,\cf4 \strokec4  opt.global_rank\cf6 \strokec6 ,\cf4 \strokec4  opt.local_rank = \\\cb1 \
\cb3             \cf7 \strokec7 ''\cf6 \strokec6 ,\cf4 \strokec4  ckpt\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \strokec4  opt.total_batch_size\cf6 \strokec6 ,\cf4 \strokec4  *apriori  \cf5 \strokec5 # reinstate\cf4 \cb1 \strokec4 \
\cb3         logger.info\cf6 \strokec6 (\cf7 \strokec7 'Resuming training from %s'\cf4 \strokec4  % ckpt\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # opt.hyp = opt.hyp or ('hyp.finetune.yaml' if opt.weights else 'hyp.scratch.yaml')\cf4 \cb1 \strokec4 \
\cb3         opt.data\cf6 \strokec6 ,\cf4 \strokec4  opt.cfg\cf6 \strokec6 ,\cf4 \strokec4  opt.hyp = check_file\cf6 \strokec6 (\cf4 \strokec4 opt.data\cf6 \strokec6 ),\cf4 \strokec4  check_file\cf6 \strokec6 (\cf4 \strokec4 opt.cfg\cf6 \strokec6 ),\cf4 \strokec4  check_file\cf6 \strokec6 (\cf4 \strokec4 opt.hyp\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # check files\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 assert\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 opt.cfg\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 or\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 opt.weights\cf6 \strokec6 ),\cf4 \strokec4  \cf7 \strokec7 'either --cfg or --weights must be specified'\cf4 \cb1 \strokec4 \
\cb3         opt.img_size.extend\cf6 \strokec6 ([\cf4 \strokec4 opt.img_size\cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ]]\cf4 \strokec4  * \cf6 \strokec6 (\cf8 \strokec8 2\cf4 \strokec4  - \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 opt.img_size\cf6 \strokec6 )))\cf4 \strokec4   \cf5 \strokec5 # extend to 2 sizes (train, test)\cf4 \cb1 \strokec4 \
\cb3         opt.name = \cf7 \strokec7 'evolve'\cf4 \strokec4  \cf2 \strokec2 if\cf4 \strokec4  opt.evolve \cf2 \strokec2 else\cf4 \strokec4  opt.name\cb1 \
\cb3         opt.save_dir = \cf2 \strokec2 str\cf6 \strokec6 (\cf4 \strokec4 increment_path\cf6 \strokec6 (\cf4 \strokec4 Path\cf6 \strokec6 (\cf4 \strokec4 opt.project\cf6 \strokec6 )\cf4 \strokec4  / opt.name\cf6 \strokec6 ,\cf4 \strokec4  exist_ok=opt.exist_ok | opt.evolve\cf6 \strokec6 ))\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # DDP mode\cf4 \cb1 \strokec4 \
\cb3     opt.total_batch_size = opt.batch_size\cb1 \
\cb3     device = select_device\cf6 \strokec6 (\cf4 \strokec4 opt.device\cf6 \strokec6 ,\cf4 \strokec4  batch_size=opt.batch_size\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  opt.local_rank != \cf8 \strokec8 -1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 assert\cf4 \strokec4  torch.cuda.device_count\cf6 \strokec6 ()\cf4 \strokec4  > opt.local_rank\cb1 \
\cb3         torch.cuda.set_device\cf6 \strokec6 (\cf4 \strokec4 opt.local_rank\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         device = torch.device\cf6 \strokec6 (\cf7 \strokec7 'cuda'\cf6 \strokec6 ,\cf4 \strokec4  opt.local_rank\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         dist.init_process_group\cf6 \strokec6 (\cf4 \strokec4 backend=\cf7 \strokec7 'nccl'\cf6 \strokec6 ,\cf4 \strokec4  init_method=\cf7 \strokec7 'env://'\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # distributed backend\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 assert\cf4 \strokec4  opt.batch_size % opt.world_size == \cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 '--batch-size must be multiple of CUDA device count'\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 assert\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.image_weights\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 '--image-weights argument is not compatible with DDP training'\cf4 \cb1 \strokec4 \
\cb3         opt.batch_size = opt.total_batch_size // opt.world_size\cb1 \
\
\cb3     \cf5 \strokec5 # Hyperparameters\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 with\cf4 \strokec4  \cf2 \strokec2 open\cf6 \strokec6 (\cf4 \strokec4 opt.hyp\cf6 \strokec6 )\cf4 \strokec4  \cf2 \strokec2 as\cf4 \strokec4  f\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         hyp = yaml.safe_load\cf6 \strokec6 (\cf4 \strokec4 f\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # load hyps\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Train\cf4 \cb1 \strokec4 \
\cb3     logger.info\cf6 \strokec6 (\cf4 \strokec4 opt\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  opt.evolve\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         tb_writer = \cf2 \strokec2 None\cf4 \strokec4   \cf5 \strokec5 # init loggers\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  opt.global_rank \cf2 \strokec2 in\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ]:\cf4 \cb1 \strokec4 \
\cb3             prefix = colorstr\cf6 \strokec6 (\cf7 \strokec7 'tensorboard: '\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3             logger.info\cf6 \strokec6 (\cf4 \strokec4 f\cf7 \strokec7 "\{prefix\}Start with 'tensorboard --logdir \{opt.project\}', view at http://localhost:6006/"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3             tb_writer = SummaryWriter\cf6 \strokec6 (\cf4 \strokec4 opt.save_dir\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # Tensorboard\cf4 \cb1 \strokec4 \
\cb3         train\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 ,\cf4 \strokec4  opt\cf6 \strokec6 ,\cf4 \strokec4  device\cf6 \strokec6 ,\cf4 \strokec4  tb_writer\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3     \cf5 \strokec5 # Evolve hyperparameters (optional)\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)\cf4 \cb1 \strokec4 \
\cb3         meta = \cf6 \strokec6 \{\cf7 \strokec7 'lr0'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1e-5\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1e-1\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # initial learning rate (SGD=1E-2, Adam=1E-3)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'lrf'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.01\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # final OneCycleLR learning rate (lr0 * lrf)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'momentum'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 0.3\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.6\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.98\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # SGD momentum/Adam beta1\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'weight_decay'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.001\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # optimizer weight decay\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'warmup_epochs'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 5.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # warmup epochs (fractions ok)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'warmup_momentum'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.95\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # warmup initial momentum\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'warmup_bias_lr'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.2\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # warmup initial bias lr\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'box'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.02\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.2\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # box loss gain\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'cls'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.2\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 4.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # cls loss gain\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'cls_pw'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.5\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # cls BCELoss positive_weight\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'obj'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.2\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 4.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # obj loss gain (scale with pixels)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'obj_pw'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.5\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # obj BCELoss positive_weight\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'iou_t'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.7\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # IoU training threshold\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'anchor_t'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 8.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # anchor-multiple threshold\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'anchors'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 2\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 10.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # anchors per output grid (0 to ignore)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'fl_gamma'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # focal loss gamma (efficientDet default gamma=1.5)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'hsv_h'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.1\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image HSV-Hue augmentation (fraction)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'hsv_s'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.9\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image HSV-Saturation augmentation (fraction)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'hsv_v'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.9\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image HSV-Value augmentation (fraction)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'degrees'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 45.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image rotation (+/- deg)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'translate'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.9\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image translation (+/- fraction)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'scale'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.9\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image scale (+/- gain)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'shear'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 10.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image shear (+/- deg)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'perspective'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.001\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image perspective (+/- fraction), range 0-0.001\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'flipud'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image flip up-down (probability)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'fliplr'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image flip left-right (probability)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'mosaic'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1.0\cf6 \strokec6 ),\cf4 \strokec4   \cf5 \strokec5 # image mixup (probability)\cf4 \cb1 \strokec4 \
\cb3                 \cf7 \strokec7 'mixup'\cf6 \strokec6 :\cf4 \strokec4  \cf6 \strokec6 (\cf8 \strokec8 1\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1.0\cf6 \strokec6 )\}\cf4 \strokec4   \cf5 \strokec5 # image mixup (probability)\cf4 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 assert\cf4 \strokec4  opt.local_rank == \cf8 \strokec8 -1\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 'DDP mode not implemented for --evolve'\cf4 \cb1 \strokec4 \
\cb3         opt.notest\cf6 \strokec6 ,\cf4 \strokec4  opt.nosave = \cf2 \strokec2 True\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 True\cf4 \strokec4   \cf5 \strokec5 # only test/save final epoch\cf4 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices\cf4 \cb1 \strokec4 \
\cb3         yaml_file = Path\cf6 \strokec6 (\cf4 \strokec4 opt.save_dir\cf6 \strokec6 )\cf4 \strokec4  / \cf7 \strokec7 'hyp_evolved.yaml'\cf4 \strokec4   \cf5 \strokec5 # save best result here\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf4 \strokec4  opt.bucket\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3             os.system\cf6 \strokec6 (\cf7 \strokec7 'gsutil cp gs://%s/evolve.txt .'\cf4 \strokec4  % opt.bucket\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # download evolve.txt if exists\cf4 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 for\cf4 \strokec4  _ \cf2 \strokec2 in\cf4 \strokec4  \cf2 \strokec2 range\cf6 \strokec6 (\cf8 \strokec8 300\cf6 \strokec6 ):\cf4 \strokec4   \cf5 \strokec5 # generations to evolve\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  Path\cf6 \strokec6 (\cf7 \strokec7 'evolve.txt'\cf6 \strokec6 )\cf4 \strokec4 .exists\cf6 \strokec6 ():\cf4 \strokec4   \cf5 \strokec5 # if evolve.txt exists: select best hyps and mutate\cf4 \cb1 \strokec4 \
\cb3                 \cf5 \strokec5 # Select parent(s)\cf4 \cb1 \strokec4 \
\cb3                 parent = \cf7 \strokec7 'single'\cf4 \strokec4   \cf5 \strokec5 # parent selection method: 'single' or 'weighted'\cf4 \cb1 \strokec4 \
\cb3                 x = np.loadtxt\cf6 \strokec6 (\cf7 \strokec7 'evolve.txt'\cf6 \strokec6 ,\cf4 \strokec4  ndmin=\cf8 \strokec8 2\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 n = \cf2 \strokec2 min\cf6 \strokec6 (\cf8 \strokec8 5\cf6 \strokec6 ,\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 ))\cf4 \strokec4   \cf5 \strokec5 # number of previous results to consider\cf4 \cb1 \strokec4 \
\cb3                 x = x\cf6 \strokec6 [\cf4 \strokec4 np.argsort\cf6 \strokec6 (\cf4 \strokec4 -fitness\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 ))][:\cf4 \strokec4 n\cf6 \strokec6 ]\cf4 \strokec4   \cf5 \strokec5 # top n mutations\cf4 \cb1 \strokec4 \
\cb3                 w = fitness\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 )\cf4 \strokec4  - fitness\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 )\cf4 \strokec4 .\cf2 \strokec2 min\cf6 \strokec6 ()\cf4 \strokec4   \cf5 \strokec5 # weights\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  parent == \cf7 \strokec7 'single'\cf4 \strokec4  \cf2 \strokec2 or\cf4 \strokec4  \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 )\cf4 \strokec4  == \cf8 \strokec8 1\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     \cf5 \strokec5 # x = x[random.randint(0, n - 1)]  # random selection\cf4 \cb1 \strokec4 \
\cb3                     x = x\cf6 \strokec6 [\cf4 \strokec4 random.choices\cf6 \strokec6 (\cf2 \strokec2 range\cf6 \strokec6 (\cf4 \strokec4 n\cf6 \strokec6 ),\cf4 \strokec4  weights=w\cf6 \strokec6 )[\cf8 \strokec8 0\cf6 \strokec6 ]]\cf4 \strokec4   \cf5 \strokec5 # weighted selection\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 elif\cf4 \strokec4  parent == \cf7 \strokec7 'weighted'\cf6 \strokec6 :\cf4 \cb1 \strokec4 \
\cb3                     x = \cf6 \strokec6 (\cf4 \strokec4 x * w.reshape\cf6 \strokec6 (\cf4 \strokec4 n\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ))\cf4 \strokec4 .\cf2 \strokec2 sum\cf6 \strokec6 (\cf8 \strokec8 0\cf6 \strokec6 )\cf4 \strokec4  / w.\cf2 \strokec2 sum\cf6 \strokec6 ()\cf4 \strokec4   \cf5 \strokec5 # weighted combination\cf4 \cb1 \strokec4 \
\
\cb3                 \cf5 \strokec5 # Mutate\cf4 \cb1 \strokec4 \
\cb3                 mp\cf6 \strokec6 ,\cf4 \strokec4  s = \cf8 \strokec8 0.8\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 0.2\cf4 \strokec4   \cf5 \strokec5 # mutation probability, sigma\cf4 \cb1 \strokec4 \
\cb3                 npr = np.random\cb1 \
\cb3                 npr.seed\cf6 \strokec6 (\cf2 \strokec2 int\cf6 \strokec6 (\cf4 \strokec4 time.time\cf6 \strokec6 ()))\cf4 \cb1 \strokec4 \
\cb3                 g = np.array\cf6 \strokec6 ([\cf4 \strokec4 x\cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \strokec4  \cf2 \strokec2 for\cf4 \strokec4  x \cf2 \strokec2 in\cf4 \strokec4  meta.values\cf6 \strokec6 ()])\cf4 \strokec4   \cf5 \strokec5 # gains 0-1\cf4 \cb1 \strokec4 \
\cb3                 ng = \cf2 \strokec2 len\cf6 \strokec6 (\cf4 \strokec4 meta\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 v = np.ones\cf6 \strokec6 (\cf4 \strokec4 ng\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 while\cf4 \strokec4  \cf2 \strokec2 all\cf6 \strokec6 (\cf4 \strokec4 v == \cf8 \strokec8 1\cf6 \strokec6 ):\cf4 \strokec4   \cf5 \strokec5 # mutate until a change occurs (prevent duplicates)\cf4 \cb1 \strokec4 \
\cb3                     v = \cf6 \strokec6 (\cf4 \strokec4 g * \cf6 \strokec6 (\cf4 \strokec4 npr.random\cf6 \strokec6 (\cf4 \strokec4 ng\cf6 \strokec6 )\cf4 \strokec4  < mp\cf6 \strokec6 )\cf4 \strokec4  * npr.randn\cf6 \strokec6 (\cf4 \strokec4 ng\cf6 \strokec6 )\cf4 \strokec4  * npr.random\cf6 \strokec6 ()\cf4 \strokec4  * s + \cf8 \strokec8 1\cf6 \strokec6 )\cf4 \strokec4 .clip\cf6 \strokec6 (\cf8 \strokec8 0.3\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 3.0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 for\cf4 \strokec4  i\cf6 \strokec6 ,\cf4 \strokec4  k \cf2 \strokec2 in\cf4 \strokec4  \cf2 \strokec2 enumerate\cf6 \strokec6 (\cf4 \strokec4 hyp.keys\cf6 \strokec6 ()):\cf4 \strokec4   \cf5 \strokec5 # plt.hist(v.ravel(), 300)\cf4 \cb1 \strokec4 \
\cb3                     hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ]\cf4 \strokec4  = \cf2 \strokec2 float\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 [\cf4 \strokec4 i + \cf8 \strokec8 7\cf6 \strokec6 ]\cf4 \strokec4  * v\cf6 \strokec6 [\cf4 \strokec4 i\cf6 \strokec6 ])\cf4 \strokec4   \cf5 \strokec5 # mutate\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Constrain to limits\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 for\cf4 \strokec4  k\cf6 \strokec6 ,\cf4 \strokec4  v \cf2 \strokec2 in\cf4 \strokec4  meta.items\cf6 \strokec6 ():\cf4 \cb1 \strokec4 \
\cb3                 hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ]\cf4 \strokec4  = \cf2 \strokec2 max\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ],\cf4 \strokec4  v\cf6 \strokec6 [\cf8 \strokec8 1\cf6 \strokec6 ])\cf4 \strokec4   \cf5 \strokec5 # lower limit\cf4 \cb1 \strokec4 \
\cb3                 hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ]\cf4 \strokec4  = \cf2 \strokec2 min\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ],\cf4 \strokec4  v\cf6 \strokec6 [\cf8 \strokec8 2\cf6 \strokec6 ])\cf4 \strokec4   \cf5 \strokec5 # upper limit\cf4 \cb1 \strokec4 \
\cb3                 hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ]\cf4 \strokec4  = \cf2 \strokec2 round\cf6 \strokec6 (\cf4 \strokec4 hyp\cf6 \strokec6 [\cf4 \strokec4 k\cf6 \strokec6 ],\cf4 \strokec4  \cf8 \strokec8 5\cf6 \strokec6 )\cf4 \strokec4   \cf5 \strokec5 # significant digits\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Train mutation\cf4 \cb1 \strokec4 \
\cb3             results = train\cf6 \strokec6 (\cf4 \strokec4 hyp.copy\cf6 \strokec6 (),\cf4 \strokec4  opt\cf6 \strokec6 ,\cf4 \strokec4  device\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3             \cf5 \strokec5 # Write mutation results\cf4 \cb1 \strokec4 \
\cb3             print_mutation\cf6 \strokec6 (\cf4 \strokec4 hyp.copy\cf6 \strokec6 (),\cf4 \strokec4  results\cf6 \strokec6 ,\cf4 \strokec4  yaml_file\cf6 \strokec6 ,\cf4 \strokec4  opt.bucket\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3         \cf5 \strokec5 # Plot results\cf4 \cb1 \strokec4 \
\cb3         plot_evolution\cf6 \strokec6 (\cf4 \strokec4 yaml_file\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 print\cf6 \strokec6 (\cf4 \strokec4 f\cf7 \strokec7 'Hyperparameter evolution complete. Best results saved as: \{yaml_file\}\\n'\cf4 \cb1 \strokec4 \
\cb3               f\cf7 \strokec7 'Command to train a new model with these hyperparameters: $ python train.py --hyp \{yaml_file\}'\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
}